{"_id":"13AHAyh9DklWxvWP","name":"Show Defenses","type":"script","sort":100001,"scope":"global","command":"pf1.documents.macros.displayDefenses()","author":"T9i9xVjdkHeFZC72","img":"systems/pf1/icons/items/armor/shield-light-metal.png"}
{"_id":"1l7Iw6xRgx8OMnJH","name":"Calculate Spellbook Price","type":"script","img":"icons/sundries/books/book-embossed-jewel-gold-purple.webp","command":"const MCONFIG = {\n  basePrice: 15,\n  spellValue: {\n    \"0\": {\n      gp: 5,\n      pages: 1,\n    },\n    \"1\": {\n      gp: 10,\n      pages: 1,\n    },\n    \"2\": {\n      gp: 40,\n      pages: 2,\n    },\n    \"3\": {\n      gp: 90,\n      pages: 3,\n    },\n    \"4\": {\n      gp: 160,\n      pages: 4,\n    },\n    \"5\": {\n      gp: 250,\n      pages: 5,\n    },\n    \"6\": {\n      gp: 360,\n      pages: 6,\n    },\n    \"7\": {\n      gp: 490,\n      pages: 7,\n    },\n    \"8\": {\n      gp: 640,\n      pages: 8,\n    },\n    \"9\": {\n      gp: 810,\n      pages: 9,\n    },\n  },\n};\n\nlet html = `\n<table>\n  <thead>\n    <tr>\n      <th>Spell level</th>\n      <th>Amount of spells</th>\n    </tr>\n  </thead>\n  <tbody>\n`;\nfor (const [k, v] of Object.entries(MCONFIG.spellValue)) {\n  html += `\n    <tr>\n      <td>${k}</td>\n      <td>\n        <input class=\"spell-input\" type=\"number\" name=\"level-${k}\" value=\"0\" data-price=\"${v.gp}\" data-pages=\"${v.pages}\" />\n      </td>\n    </tr>\n  `;\n}\nhtml += `\n  </tbody>\n  <thead>\n    <tr>\n      <th>Spellbook price</th>\n      <th>Pages required</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><input class=\"spellbook-price\" type=\"text\" disabled name=\"spellbook-price\" value=\"${MCONFIG.basePrice}\" /></td>\n      <td><input class=\"spellbook-pages\" type=\"text\" disabled name=\"page-value\" value=\"0\" /></td>\n    </tr>\n  </tbody>\n</table>\n\n<div class=\"help-text\">\n  Typical spellbooks can only hold 100 pages.\n</div>\n`;\n\n// -------------------------\n// Functions\n// -------------------------\n\nconst _onChange = function (event) {\n  event.preventDefault();\n  const html = $(event.target.closest(\".window-content\"));\n\n  let pages = 0;\n  let price = MCONFIG.basePrice;\n  html.find(\".spell-input\").each((idx, elem) => {\n    const amount = Number(elem.value);\n    if (Number.isNaN(amount)) return;\n\n    price += Number(elem.dataset.price) * amount;\n    pages += Number(elem.dataset.pages) * amount;\n  });\n\n  html.find(\".spellbook-price\").attr(\"value\", price);\n  html.find(\".spellbook-pages\").attr(\"value\", pages);\n};\n\n// -------------------------\n// Dialog\n// -------------------------\n\nconst d = new Dialog({\n  title: \"Calculate spellbook value\",\n  content: html,\n  buttons: {},\n  render: (html) => {\n      html.find(\"input.spell-input\").change(_onChange.bind(this));    \n  }\n}).render(true);"}
{"name":"Wild Shape","type":"script","img":"systems/pf1/icons/skills/green_27.jpg","command":"// Author: @Adam\n\n// SETUP NEEDED: for each transformation option you want, please enter it as below\n// you also need to set imageFolder to the location of where you store your tokens.\n// token art is selected by name & as a png, so for example the image for Bat is located at \"worlds/golarion/tokens/Bestiary/Bat.png\"\n\n// support for elemental body is not complete yet - only air elemental is hardcoded\n\nconst imageFolder = \"worlds/golarion/tokens/Bestiary\";\n\nconst transformationOptions = {\n\tBat: {\n\t\tsize: \"diminutive\",\n\t\tspellSource: \"beast shape\",\n\t},\n\t\"Giant Squid\": {\n\t\tsize: \"huge\",\n\t\tspellSource: \"beast shape\",\n\t},\n\tTendriculos: {\n\t\tsize: \"huge\",\n\t\tspellSource: \"plant shape\",\n\t},\n\t\"Air Elemental\": {\n\t\tsize: \"huge\",\n\t\tspellSource: \"elemental body\",\n\t},\n};\n\nconst sizes = [\n\t\"diminutive\",\n\t\"tiny\",\n\t\"small\",\n\t\"medium\",\n\t\"large\",\n\t\"huge\",\n\t\"gargantuan\",\n\t\"colossal\",\n];\n\nconst sizeTranslation = {\n\tfine: \"fine\",\n\tdiminutive: \"dim\",\n\ttiny: \"tiny\",\n\tsmall: \"sm\",\n\tmedium: \"med\",\n\tlarge: \"lg\",\n\thuge: \"huge\",\n\tgargantuan: \"grg\",\n\tcolossal: \"col\",\n};\n\nconst createSizeObject = ({ w, h, scale }) => {\n\treturn {\n\t\twidth: w,\n\t\theight: h,\n\t\tscale,\n\t};\n};\n\nconst mediumOrBigger = (size) => {\n\treturn sizes.indexOf(size) >= sizes.indexOf(\"medium\");\n};\n\nconst createAbilityChange = (formula, subTarget) => {\n\tformula = \"\" + formula;\n\treturn {\n\t\tformula,\n\t\tpriority: 1,\n\t\ttarget: \"ability\",\n\t\tsubTarget,\n\t\tmodifier: \"size\",\n\t};\n};\n\nconst createNACChange = (formula) => {\n\tformula = \"\" + formula;\n\treturn {\n\t\tformula,\n\t\tpriority: 1,\n\t\ttarget: \"ac\",\n\t\tsubTarget: \"nac\",\n\t\tmodifier: \"size\",\n\t};\n};\n\nconst createSpeedChange = (formula, subTarget) => {\n\tformula = \"\" + formula;\n\treturn {\n\t\tformula,\n\t\tpriority: 1,\n\t\ttarget: \"speed\",\n\t\tsubTarget,\n\t\tmodifier: \"size\",\n\t};\n};\n\nconst createBuffChanges = (name) => {\n\tconst creature = transformationOptions[name];\n\tconst bulking = mediumOrBigger(creature.size);\n\tlet buffLevel = null;\n\n\tconst changes = [];\n\n\tif (bulking) {\n\t\tbuffLevel = sizes.indexOf(creature.size) - sizes.indexOf(\"medium\") + 1;\n\t}\n\telse {\n\t\tbuffLevel = sizes.indexOf(\"medium\") - sizes.indexOf(creature.size);\n\t}\n\n\tswitch (creature.spellSource.toLowerCase()) {\n\t\tcase \"beast shape\": {\n\t\t\tconst mainBonus = buffLevel * 2;\n\t\t\tconst nacBonus = buffLevel * 2;\n\t\t\tconst penalty = buffLevel > 1 ? -(buffLevel * 2 - 2) : 0;\n\t\t\tconst mainBonusAbility = bulking ? \"str\" : \"dex\";\n\t\t\tconst penaltyAbility = bulking ? \"dex\" : \"str\";\n\n\t\t\tchanges.push(createAbilityChange(mainBonus, mainBonusAbility));\n\t\t\tchanges.push(createAbilityChange(penalty, penaltyAbility));\n\t\t\tchanges.push(createNACChange(nacBonus));\n\t\t\tbreak;\n\t\t}\n\t\tcase \"plant shape\": {\n\t\t\tconst nacBonus = buffLevel * 2;\n\t\t\tif (bulking) {\n\t\t\t\tconst strBonus = Math.pow(2, buffLevel);\n\t\t\t\tconst conBonus = Math.max(2, buffLevel / 2);\n\t\t\t\tconst penalty = -(buffLevel > 2 ? 2 : 0);\n\n\t\t\t\tchanges.push(createAbilityChange(strBonus, \"str\"));\n\t\t\t\tchanges.push(createAbilityChange(conBonus, \"con\"));\n\t\t\t\tchanges.push(createAbilityChange(penalty, \"dex\"));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst conBonus = buffLevel * 2;\n\t\t\t\tchanges.push(createAbilityChange(conBonus, \"con\"));\n\t\t\t}\n\t\t\tchanges.push(createNACChange(nacBonus));\n\t\t\tbreak;\n\t\t}\n\t\tcase \"elemental body\": {\n\t\t\tif (name === \"Air Elemental\") {\n\t\t\t\tchanges.push(createAbilityChange(4, \"str\"));\n\t\t\t\tchanges.push(createAbilityChange(6, \"dex\"));\n\t\t\t\tchanges.push(createNACChange(4));\n\t\t\t\tchanges.push(createSpeedChange(120, \"flySpeed\"));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tui.notifications.error(\n\t\t\t\t`Cannot find spellSource (${creature.spellSource.toLowerCase()}) in programmed list. Ensure there are no typos.`\n\t\t\t);\n\t\t}\n\t}\n\n\treturn changes;\n};\n\nconst createWildshapeBuff = async (caster, data) => {\n\tconst itemData = foundry.utils.mergeObject({\n\t\ttype: \"buff\",\n\t\tname: \"Wild Shape (Auto)\",\n\t\tsystem: { subType: \"temp\", level: 1 },\n\t}, data);\n\t\t// Get templates\n\tconst [wsbuff] = await caster.createEmbeddedDocuments(\"Item\", [itemData]);\n\treturn wsbuff;\n};\n\nconst getWildshapeBuff = (caster) => caster.itemTypes.buff.find(i => i.name === \"Wild Shape (Auto)\");\n\nconst transform = async (caster, token, name) => {\n\t// Save original form\n\tif (!caster.getFlag(\"pf1\", \"wildshape\")) {\n\t\tconst originalData = {\n\t\t\timage: caster.prototypeToken.texture.src,\n\t\t\tsize: caster.system.traits.size,\n\t\t};\n\t\tawait caster.setFlag(\"pf1\", \"wildshape\", { originalData });\n\t}\n\n\t// Transform\n\tconst creature = transformationOptions[name];\n\tconst changes = createBuffChanges(name);\n\n\tlet buff = getWildshapeBuff(caster);\n\tif (!buff) buff = await createWildshapeBuff(caster, { system: { changes, active: true } });\n\n\tawait caster.update({ \"system.traits.size\": sizeTranslation[creature.size] });\n\tawait token.document.update({\n\t\ttexture: { src: `${imageFolder}/${name}.png` },\n\t\t...createSizeObject(pf1.config.tokenSizes[sizeTranslation[creature.size]]),\n\t});\n};\n\nconst revertForm = async (caster, token) => {\n\tconst originalData = caster.getFlag(\"pf1\", \"wildshape\")?.originalData;\n\tawait getWildshapeBuff(caster).setActive(false);\n\tif (originalData) {\n\t\tawait caster.update({ \"system.traits.size\": originalData.size, \"flags.pf1.-=wildshape\": null });\n\t\tawait token.document.update({\n\t\t\ttexture: { src: originalData.image },\n\t\t\t...createSizeObject(pf1.config.tokenSizes[originalData.size]),\n\t\t});\n\t}\n};\n\nif (canvas.tokens.controlled.length !== 1) return void ui.notifications.warn(\"Select a token.\");\n\nconst buttons = Object.keys(transformationOptions).map((optionName) => ({\n\tlabel: optionName,\n\tcallback: () => transform(token.actor, token, optionName),\n}));\n\nif (token.actor.getFlag(\"pf1\", \"wildshape\")) {\n\tbuttons.push({\n\t\tlabel: \"Revert\",\n\t\ticon: `<i class=\"fas fa-user\"></i>`,\n\t\tcallback: () => revertForm(token.actor, token),\n\t});\n}\n\nDialog.wait({\n\ttitle: \"Wild Shape\",\n\tcontent: \"Choose creature.\",\n\tbuttons,\n});","_id":"2It7zEVpm6WqpJmm"}
{"_id":"8VcUUx7d4TX4WTkt","name":"Award XP","type":"script","img":"icons/svg/book.svg","command":"// CONFIGURATION\n// If one or more tokens are selected, those will be used instead of the listed actors\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.filter(o => o.isPC);\nactors = actors.filter(o => o.testUserPermission(game.user, 'OWNER'));\n\nif (!actors.length) ui.notifications.warn('No applicable actor(s) found');\nelse {\n  const appCls = pf1.applications.ExperienceDistributor;\n  new appCls(actors).render(true);\n}"}
{"name":"Show Actor Information","type":"script","scope":"global","command":"// CONFIGURATION\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC && o.testUserPermission(game.user, \"OWNER\"));\nactors = actors.filter(o => o.testUserPermission(game.user, \"OWNER\"));\n\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\nelse {\n  const msg = `Choose the information you want to show for the following actor(s): <b>${actors.map(o => o.name).join(\"</b>, <b>\")}</b>`;\n  \n  new Dialog({\n    title: \"Show Actor Information\",\n    content: `<p>${msg}</p>`,\n    buttons: {\n      fort: {\n        label: \"Social Defenses\",\n        callback: () => {\n          let c = \"\";\n          // Add demoralize DC\n          c += `<table><thead><tr><td colspan=\"2\">Demoralize (Intimidate)</td><tr><td>Character</td><td>DC</td></thead><tbody>`;\n          for (let a of actors) {\n            const rollData = a.getRollData({ forceRefresh: false });\n            const dc = 10 + rollData.attributes.hd.total + rollData.abilities.wis.mod;\n            c += `<tr><td>${a.name}</td><td>${dc}</td></tr>`;\n          }\n          c += \"</tbody></table>\";\n          // Add diplomacy DCs\n          c += `<table><thead><tr><td colspan=\"3\">Diplomacy</td></tr><tr><td>Character</td><td>Starting Attitude</td><td>DC</td><thead><tbody>`;\n          for (let a of actors) {\n            c += `<tr><td rowspan=\"5\">${a.name}</td>`;\n            const rollData = a.getRollData({ forceRefresh: false });\n            const dipArr = [{ label: \"Hostile\", base: 25 }, { label: \"Unfriendly\", base: 20 }, { label: \"Indifferent\", base: 15 }, { label: \"Friendly\", base: 10 }, { label: \"Helpful\", base: 0 }];\n            for (let b = 0; b < dipArr.length; b++) {\n              const o = dipArr[b];\n              if (b > 0) c += \"<tr>\";\n              c += `<td>${o.label}</td><td>${o.base + rollData.abilities.cha.mod}</td></tr>`;\n            }\n          }\n          c += \"</tbody></table>\";\n          // Render chat message\n          let messageData = {\n            content: c,\n            user: game.user._id,\n            speaker: ChatMessage.getSpeaker({ user: game.user }),\n            type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n          };\n          messageData = ChatMessage.applyRollMode(messageData, game.settings.get(\"core\", \"rollMode\"));\n          ChatMessage.create(messageData);\n        },\n      },\n    },\n  }).render(true);\n}","author":"61klraqiWb97OOLa","img":"systems/pf1/icons/skills/red_25.jpg","_id":"NozVDiFkfZcBg4Hg","sort":0}
{"_id":"ON7b8yS1lcBxkMuo","name":"Roll Saving Throw","type":"script","scope":"global","command":"// CONFIGURATION\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.filter(o => o.isPC && o.testUserPermission(game.user, \"OWNER\"));\nactors = actors.filter(o => o.testUserPermission(game.user, \"OWNER\"));\n\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\nelse {\n  const _roll = async function(type) {\n    for (let a = 0; a < actors.length; a++) {\n      const o = actors[a];\n      await o.rollSavingThrow(type, { event: new MouseEvent({}), noSound: a > 0, });\n    }\n  };\n\n  const msg = `Choose a saving throw to roll for the following actor(s): <b>${actors.map(o => o.name).join(\"</b>, <b>\")}</b>`;\n\n  new Dialog({\n    title: \"Roll saving throw\",\n    content: `<p>${msg}</p>`,\n    buttons: {\n      fort: {\n        label: \"Fortitude\",\n        callback: () => _roll(\"fort\"),\n      },\n      ref: {\n        label: \"Reflex\",\n        callback: () => _roll(\"ref\"),\n      },\n      will: {\n        label: \"Will\",\n        callback: () => _roll(\"will\"),\n      },\n    },\n  }).render(true);\n}","author":"T9i9xVjdkHeFZC72","img":"systems/pf1/icons/feats/diehard.jpg","sort":0}
{"_id":"mL9k7wUzzFbj1NmY","name":"Roll Skill","type":"script","scope":"global","command":"// CONFIGURATION\n// If one or more tokens are selected, those will be used instead of the listed actors\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n  skills: [\"per\", \"sen\", \"ste\", \"sur\"],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.filter(o => o.isPC && o.testUserPermission(game.user, \"OWNER\"));\nactors = actors.filter(o => o.testUserPermission(game.user, \"OWNER\"));\n\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\nelse {\n  const _roll = async function(type) {\n    let madeSound = false;\n    for (let a = 0;a < actors.length; a++) {\n      const o = actors[a];\n      const info = o.getSkillInfo(type);\n      if (!info) continue;\n      await o.rollSkill(type, { event: new MouseEvent({}), skipDialog: true, noSound: madeSound, });\n      madeSound = true;\n    }\n  };\n\n  const buttons = c.skills.reduce((cur, s) => {\n    let info;\n    for (const o of actors) {\n      info = o.getSkillInfo(s);\n      if (info) break;\n    }\n    if (!info) return cur;\n    const label = info.name;\n    cur[s] = {\n      label: label,\n      callback: () => _roll(s),\n    };\n    return cur;\n  }, {});\n\n  const msg = `Choose a skill to roll for the following actor(s): <b>${actors.map(o => o.name).join(\"</b>, <b>\")}</b>`;\n\n  new Dialog({\n    title: \"Roll saving throw\",\n    content: `<p>${msg}</p>`,\n    buttons: buttons,\n  }).render(true);\n}","author":"T9i9xVjdkHeFZC72","img":"systems/pf1/icons/feats/skill-focus.jpg","sort":0}
{"name":"Toggle Buff","type":"script","img":"systems/pf1/icons/spells/protect-blue-1.jpg","command":"// CONFIGURATION\n// If one or more tokens are selected, those will be used instead of the listed actors\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n\tactorNames: [],\n\tbuffName: 'Mage Armor'\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.filter(o => o.isPC);\nactors = actors.filter(o => o.isOwner);\nif (!actors.length) return void ui.notifications.warn('No applicable actor(s) found');\n\nfor (const actor of actors) {\n\tconst buff = actor.itemTypes.buff.find(o => o.name === c.buffName);\n\tbuff?.setActive(!buff.isActive);\n}","_id":"rrSdHpdneqEhrYjK"}
{"_id":"yEPv1InFUHWnh1kt","name":"Create Loot Sheets","type":"script","img":"systems/pf1/icons/items/inventory/chest-light.jpg","command":"/**\n * Create Loot Sheets\n *\n * Creates new loot sheet actors in the defined folder.\n */\n\n/**\n * CONFIGURATION\n *\n * @param {string} folder - A string of folder names, separated by '/' (slashes)\n * @param {number} defaultPermission - A constant number, to be gathered from the global object CONST.DOCUMENT_PERMISSION_LEVELS (for quick reference, you can replace 'OBSERVER' with one of the following: 'NONE', 'LIMITED' or 'OWNER'\n * @param {string} sheetType - Change this if you have a module installed for a different loot sheet type.\n */\nconst c = {\n\tfolder: 'Misc/Loot',\n\tdefaultPermission: CONST.DOCUMENT_PERMISSION_LEVELS.OBSERVER,\n\tsheetType: 'pf1.ActorSheetPFNPCLoot',\n};\n\n// END CONFIGURATION\n\nasync function createFromTokens(tokens) {\n\tlet lastFolder = null;\n\n\tasync function createFolders() {\n\t\tlet lastIndex = 0;\n\t\tconst folders = game.folders.filter(f => f.type === 'Actor');\n\t\tconst folderNames = c.folder.split('/');\n\t\tfor (let a = 0; a < folderNames.length; a++) {\n\t\t\tconst curName = folderNames[a];\n\t\t\tconst prevName = a > 0 ? folderNames[a - 1] : null;\n\n\t\t\tconst f = folders.find(o => o.name === curName && (o.parent ? o.parent.name === prevName : true));\n\t\t\tif (f) {\n\t\t\t\tlastFolder = f;\n\t\t\t\tlastIndex = a + 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (let a = lastIndex; a < folderNames.length; a++) {\n\t\t\tconst newFolder = await Folder.create({\n\t\t\t\tname: folderNames[a],\n\t\t\t\tparent: lastFolder?.id ?? null,\n\t\t\t\ttype: 'Actor',\n\t\t\t});\n\t\t\tlastFolder = newFolder;\n\t\t}\n\t}\n\n\t// Create folder(s)\n\tif (c.folder) await createFolders();\n\n\t// Gather currency\n\tconst currency = { pp: 0, gp: 0, sp: 0, cp: 0 };\n\ttokens.forEach(t => {\n\t\tfor (const cc of Object.keys(currency))\n\t\t\tcurrency[cc] += t.actor.system.currency[cc];\n\t});\n\n\t// Create loot NPC for selected tokens\n\tconst name = '(Loot) ' + tokens.map(t => t.name).join(', ');\n\n\tconst lootNPC = await Actor.create({\n\t\tname,\n\t\ttype: 'npc',\n\t\timg: tokens[0].texture.src,\n\t\tfolder: lastFolder?.id ?? null,\n\t\tpermission: {\n\t\t\tdefault: c.defaultPermission,\n\t\t},\n\t\tflags: {\n\t\t\tcore: { sheetClass: c.sheetType },\n\t\t},\n\t\tsystem: { currency },\n\t});\n\n\tconst scrubItem = (i) => {\n\t\tdelete i.system.links; // Scrap links\n\t\tdelete i._id; // scrap ID\n\t\tdelete i.system.tag; // scrap tag\n\t\treturn i;\n\t};\n\n\t// Gather item data\n\tconst itemData = tokens.reduce((cur, o) => {\n\t\tfor (const i of o.actor.items) {\n\t\t\tconst itemData = i.toObject();\n\t\t\tif (!i.isPhysical || i.system.quantity <= 0) continue;\n\t\t\tscrubItem(itemData);\n\t\t\t// Check for identical data\n\t\t\tconst oldItem = cur.find(i2 => i2.name === i.name && i2.type === i.type);\n\t\t\tlet sameItem = false;\n\t\t\tif (oldItem) {\n\t\t\t\t// Ensure the objects are similar enough (quantity is the only thing allowed to differ)\n\t\t\t\tconst oldKeys = Object.keys(flattenObject(diffObject(itemData, oldItem)));\n\t\t\t\tsameItem = oldKeys.length == 1 && oldKeys.includes('quantity') || oldKeys.length == 0;\n\t\t\t}\n\n\t\t\tif (oldItem && sameItem) oldItem.system.quantity += i.system.quantity;\n\t\t\telse cur.push(itemData);\n\t\t}\n\t\treturn cur;\n\t}, []);\n\n\t// Add items\n\tawait lootNPC.createEmbeddedDocuments('Item', itemData);\n}\n\n// Get selected tokens\nconst tokens = canvas.tokens.controlled;\nif (tokens.length) createFromTokens(tokens);\nelse ui.notifications?.warn('No tokens selected to convert into loot.');"}

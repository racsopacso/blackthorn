/**
 * Module-based constants
 */
const MODULE = {
    ID: 'token-action-hud-pf1'
};

/**
 * Core module
 */
const CORE_MODULE = {
    ID: 'token-action-hud-core'
};

/**
 * Core module version required by the system module
 */
const REQUIRED_CORE_MODULE_VERSION = '1.5';

const ROLL_TYPE = {
    abilityCheck: 'abilityCheck',
    addToCombat: 'addToCombat',
    bab: 'bab',
    buff: 'buff',
    casterLevel: 'casterLevel',
    cmb: 'cmb',
    concentration: 'concentration',
    condition: 'condition',
    defenses: 'defenses',
    endTurn: 'endTurn',
    initiative: 'initiative',
    item: 'item',
    makeInvisible: 'makeInvisible',
    makeVisible: 'makeVisible',
    melee: 'melee',
    openSettings: 'openSettings',
    openTokenConfig: 'openTokenConfig',
    ranged: 'ranged',
    removeFromCombat: 'removeFromCombat',
    rest: 'rest',
    save: 'save',
    skill: 'skill',
    toggleSkip: 'toggleSkip',
    toggleTahGrid: 'toggleTahGrid',
    toggleUntrainedSkills: 'toggleUntrainedSkills',
};

class Utils {
    static isEmptyObject = (obj) => !Object.keys(obj).length;

    static localize = (key, opts = {}) => {
        const myKey = `${MODULE.ID}.${key}`;
        return Utils.isEmptyObject(opts)
            ? (game.i18n.localize(myKey) === myKey ? game.i18n.localize(key) : game.i18n.localize(myKey))
            : (game.i18n.format(myKey, opts) === myKey ? game.i18n.format(key, opts) : game.i18n.format(myKey, opts));
    }

    static getFirstActiveGM = () => pf1.utils.getFirstActiveGM();
    static isFirstGM = () => this.getFirstActiveGM() === game.user;
    static isCurrentUser = (userId) => game.user.id === userId;
    static doOnce = (func) => this.handleSingleOwner(game.user.id, func);
    static handleSingleOwner = async (userId, func) => {
        const gm = this.getFirstActiveGM();

        if (this.isFirstGM() || (!gm && this.isCurrentUser(userId))) {
            await func();
        }
    }

    static #itemHasActions = (item) => !!this.getItemActions(item).length;
    static canUseItem = (item) => this.#itemHasActions(item) || !!item.getScriptCalls("use").length;
    static getItemActions = (item) => {
        const actions = item.actions;
        return actions ? [...actions] : [];
        // const unchained = game.settings.get('pf1', 'unchainedActionEconomy');

        // disabling this but leaving it here for future use -- "passive" actions are still actions because they can still be used.
        // const isActive = (action) => unchained
        //     ? action.data.unchainedAction?.activation?.type && action.data.unchainedAction.activation.type !== 'passive'
        //     : action.data.activation?.type && action.data.activation?.type !== 'passive';

        // leaving this here again -- it seems right, but an action might not have an activation type configured but can still be used
        // const isAction = (action) => unchained
        //     ? action.data.unchainedAction?.activation?.type
        //     : action.data.activation?.type;
        // return (actions || []).filter(isAction);
    }

    /**
     * Get actor from the token or actor object
     * @param {string} actorId The actor id
     * @param {string} tokenId The token id
     * @returns {object}       The actor
     */
    static getActor(actorId, tokenId) {
        let token = null;
        if (tokenId) token = canvas.tokens.placeables.find((token) => token.id === tokenId);
        if (token) return token.actor
        return game.actors.get(actorId)
    }

    /**
     * Get item from the actor object
     * @param {object} actor  The actor
     * @param {string} itemId The item id
     * @returns {object}      The item
     */
    static getItem(actor, itemId) {
        return actor.items.get(itemId)
    }

    /**
     * Get token
     * @param {string} tokenId The token id
     * @returns {object}       The token
     */
    static getToken(tokenId) {
        return canvas.tokens.placeables.find((token) => token.id === tokenId)
    }
}

/**
 * Default categories and groups
 */
let GROUPS = null;

const gearSubtypes = ['gear', 'adventuring', 'tool', 'reagent', 'remedy', 'herb', 'animal', 'animalGear'];
const miscSubtypes = ['misc', 'food', 'entertainment', 'vehicle'];
const tradeSubtypes = ['tradeGoods', 'treasure'];
const handledItemTypes = [
    'attack',
    'buff',
    'consumable',
    'container',
    'equipment',
    'feat',
    'implant',
    'loot',
    'spell',
    'weapon',
];

const GROUP_MAP = {
    combat: {
        id: 'combat',
        name: 'PF1.Combat',
        groups: {
            // misc actions not defined by Items (e.g. initiative, cmb, etc)
            base: { id: 'combat-base', name: 'PF1.Base', settings: { showTitle: false } },

            weaponAttaack: { id: 'combat-weaponAttack', name: 'PF1.Subtypes.Item.attack.weapon.Plural', filter: (item) => item.type === 'attack' && item.subType === 'weapon' },
            naturalAttack: { id: 'combat-naturalAttack', name: 'PF1.Subtypes.Item.attack.natural.Plural', filter: (item) => item.type === 'attack' && item.subType === 'natural' },
            classAbilities: { id: 'combat-classAbilities', name: 'PF1.Subtypes.Item.attack.ability.Plural', filter: (item) => item.type === 'attack' && item.subType === 'ability' },
            racialAbilities: { id: 'combat-racialAbilities', name: 'PF1.Subtypes.Item.attack.racial.Plural', filter: (item) => item.type === 'attack' && item.subType === 'racialAbility' },
            items: { id: 'combat-items', name: 'PF1.Subtypes.Item.attack.item.Plural', filter: (item) => item.type === 'attack' && item.subType === 'item' },
            miscellaneous: { id: 'combat-miscellaneous', name: 'PF1.Subtypes.Item.attack.misc.Plural', filter: (item) => item.type === 'attack' && item.subType === 'misc' },

            other: {
                id: 'combat-other',
                name: 'PF1.Other',
                filter: (item) => {
                    Object.entries(GROUP_MAP.combat.groups)
                        .filter(([key, _]) => key !== 'other' && key !== 'base')
                        .map(([_, value]) => value.filter)
                        .every((filter) => !filter(item));
                },
            },
        },
    },
    saves: {
        id: 'saves',
        name: 'PF1.SavingThrowPlural',
        groups: {
            saves: { id: 'saves-saves', name: 'PF1.SavingThrowPlural', settings: { showTitle: false } },
        },
    },
    checks: {
        id: 'checks',
        name: 'PF1.BuffTarAbilityChecks',
        groups: {
            checks: { id: 'checks-checks', name: 'PF1.BuffTarAbilityChecks', settings: { showTitle: false } },
        },
    },
    inventory: {
        id: 'inventory',
        name: 'PF1.Inventory',
        groups: {
            weapons: { id: 'inventory-weapons', name: 'PF1.InventoryWeapons', filter: (item) => item.type === 'weapon' },
            armor: { id: 'inventory-armor', name: 'PF1.ArmorOrShield', filter: (item) => item.type === 'equipment' && ['armor', 'shield'].includes(item.subType) },
            equipment: { id: 'inventory-equipment', name: 'PF1.InventoryEquipment', filter: (item) => item.type === 'equipment' && ['wondrous', 'other', 'clothing'].includes(item.subType) },
            implant: { id: 'inventory-implant', name: 'PF1.InventoryImplants', filter: (item) => item.type === 'implant' },
            consumables: { id: 'inventory-consumables', name: 'PF1.InventoryConsumables', filter: (item) => item.type === 'consumable' },
            gear: { id: 'inventory-gear', name: 'PF1.Subtypes.Item.loot.gear.Plural', filter: (item) => item.type === 'loot' && gearSubtypes.includes(item.subType) },
            ammunition: { id: 'inventory-ammunition', name: 'PF1.Subtypes.Item.loot.ammo.Plural', filter: (item) => item.type === 'loot' && item.subType === 'ammo' },
            miscellaneous: { id: 'inventory-miscellaneous', name: 'PF1.Subtypes.Item.loot.misc.Plural', filter: (item) => item.type === 'loot' && miscSubtypes.includes(item.subType) },
            tradeGoods: { id: 'inventory-tradeGoods', name: 'PF1.Subtypes.Item.loot.tradeGoods.Plural', filter: (item) => item.type === 'loot' && tradeSubtypes.includes(item.subType) },
            containers: { id: 'inventory-containers', name: 'PF1.InventoryContainers', filter: (item) => item.type === 'container' },

            // leftovers that could be from other mods or from a change in pf1
            other: {
                id: 'inventory-other',
                name: 'PF1.Other',
                filter: (item) => {
                    Object.entries(GROUP_MAP.inventory.groups)
                        .filter(([key, _]) => key !== 'other')
                        .map(([_, value]) => value.filter)
                        .every((filter) => !filter(item));
                },
            },
        },
    },
    features: {
        id: 'features',
        name: 'PF1.Features',
        groups: {
            classFeat: { id: 'features-classFeat', name: 'PF1.Subtypes.Item.feat.classFeat.Plural', filter: (item) => item.type === 'feat' && item.subType === 'classFeat' },
            feat: { id: 'features-feat', name: 'PF1.Subtypes.Item.feat.feat.Plural', filter: (item) => item.type === 'feat' && item.subType === 'feat' },
            racial: { id: 'features-racial', name: 'PF1.Subtypes.Item.feat.racial.Plural', filter: (item) => item.type === 'feat' && item.subType === 'racial' },
            template: { id: 'features-template', name: 'PF1.Subtypes.Item.feat.template.Plural', filter: (item) => item.type === 'feat' && item.subType === 'template' },
            trait: { id: 'features-trait', name: 'PF1.Subtypes.Item.feat.trait.Plural', filter: (item) => item.type === 'feat' && item.subType === 'trait' },
            misc: { id: 'features-misc', name: 'PF1.Subtypes.Item.feat.misc.Plural', filter: (item) => item.type === 'feat' && item.subType === 'misc' },

            // spheres of power sections
            combatTalents: { id: 'features-combat-talents', name: 'PF1SPHERES.CombatTalentPlural', filter: (item) => item.type === 'feat' && item.subType === 'combatTalent' },
            magicTalents: { id: 'features-magic-talents', name: 'PF1SPHERES.MagicTalentPlural', filter: (item) => item.type === 'feat' && item.subType === 'magicTalent' },

            // leftovers that could be from other mods or from a change in pf1
            other: {
                id: 'features-other',
                name: 'PF1.Other',
                filter: (item) => {
                    Object.entries(GROUP_MAP.features.groups)
                        .filter(([key, _]) => key !== 'other')
                        .map(([_, value]) => value.filter)
                        .every((filter) => !filter(item));
                },
            },
        },
    },
    skills: {
        id: 'skills',
        name: 'PF1.Skills',
        groups: {
            skills: { id: 'skills-skills', name: 'PF1.Skills', settings: { showTitle: false } },
            utils: { id: 'skills-utils', name: 'categories.utility' }
        },
    },
    spells: {
        id: 'spells',
        name: 'PF1.Spells',
        groups: {
            spells: { id: 'spells-spells', name: 'PF1.Spells', settings: { showTitle: false } },
        },
    },
    buffs: {
        id: 'buffs',
        name: 'PF1.Buffs',
        groups: {
            actions: { id: 'buffs-actions', name: `${MODULE.ID}.categories.activeBuffActions` },
            temporary: { id: 'buffs-temporary', name: 'PF1.Temporary' },
            item: { id: 'buffs-item', name: 'PF1.Item' },
            permanent: { id: 'buffs-permanent', name: 'PF1.Permanent' },
            miscellaneous: { id: 'buffs-miscellaneous', name: 'PF1.Misc' },

            other: { id: 'buffs-other', name: 'PF1.Other' },
        },
    },
    conditions: {
        id: 'conditions',
        name: 'PF1.ConditionPlural',
        groups: {
            conditions: { id: 'conditions-conditions', name: 'PF1.ConditionPlural', settings: { showTitle: false } },
        },
    },
    other: {
        id: 'other',
        name: 'PF1.Other',
        groups: {
            other: { id: 'other-other', name: 'PF1.Other', filter: (item) => !handledItemTypes.includes(item.type) },
        },
    },
    utility: {
        id: 'utility',
        name: 'categories.utility',
        groups: {
            rest: { id: 'utility-rest', name: 'PF1.Rest' },
            token: { id: 'utility-token', name: 'Token' },
            utility: { id: 'utility-utility', name: 'categories.utility' },
        },
    },
};

Hooks.on('i18nInit', async () => {
    // this will have to be updated if I ever need nested pre-defined groups
    const allGroups = [];
    const getGroups = (catMap) => {
        const groups = [];
        if (catMap.groups) {
            Object.keys(catMap.groups).forEach((subKey) => {
                const subMap = catMap.groups[subKey];
                subMap.name = Utils.localize(subMap.name);
                subMap.nestId = `${catMap.nestId || catMap.id}_${subMap.id}`;
                subMap.type = 'system';
                subMap.listName = `${catMap.name} - ${subMap.name}`;
                const sub = {
                    ...subMap,
                    type: 'system',
                };
                groups.push(sub);
                allGroups.push(sub);
            });
        }
        return groups;
    };

    const layout = Object.keys(GROUP_MAP).map((catKey) => {
        const catMap = GROUP_MAP[catKey];
        catMap.nestId = catMap.nestId || catMap.id;
        catMap.name = Utils.localize(catMap.name);
        return {
            ...catMap,
            groups: getGroups(catMap),
        };
    });

    GROUPS = {
        layout,
        groups: allGroups,
    };
});

class ActionBuilderActorData {
    #_knownActorTypes = ['character', 'npc'];

    #_fallbackActor = null;
    get actor() { return this.#_fallbackActor || this.actors[0] || {}; }

    #_fallbackToken = null;
    get token() { return this.#_fallbackToken || this.tokens[0] || {}; }

    get actors() { return this.#_fallbackActor ? [this.#_fallbackActor] : this.tokens.map(token => token.actor).filter(x => !!x); }
    get tokens() { return this.#_fallbackToken ? [this.#_fallbackToken] : canvas.tokens.controlled; }

    get actorId() { return this.actor?.id; }
    get actorIds() { return this.actors?.map(x => x.id) ?? []; }
    get isMulti() { return (this.actors?.length ?? 0) > 1; }
    get isSingle() { return !this.isMulti; }
    get tokenId() { return this.token?.id; }
    get tokenIds() { return this.tokens?.map(x => x.id) ?? []; }

    get isValid() {
        const filter = (actor) => this.#_knownActorTypes.includes(actor?.type);
        const isValid = this.actors?.some(filter) ?? false;
        if (!this.actors.every(filter)) {
            console.warn('TAH detected invalid selected actor');
        }
        return isValid;
    }

    get inCombat() {
        return !!this.combatants.length;
    }

    get combatant() { return this.combatants[0] || {}; }
    get combatants() {
        if (this.#_fallbackActor) {
            return game.combat?.combatants.filter((combatant) => combatant.actor === this.#_fallbackActor) ?? [];
        }

        const combatantants = game.combat?.combatants ?? [];
        return combatantants.filter((combatant) => this.actors.find((actor) => combatant.actor === actor));
    }

    get isCurrentCombatant() { return !this.isMulti && this.inCombat && game.combat?.combatant?.id === this.combatant.id; }

    #_items = null;
    get items() {
        return this.#_items ??=
            this.actor.items
                ? this.actor.items
                    .filter((item) => Utils.canUseItem(item))
                    .sort((a, b) => a.name < b.name ? -1 : 1)
                : [];
    }

    #_unusableItems = null;
    get unusableItems() {
        return this.#_unusableItems ??=
            this.actor.items
                ? this.actor.items
                    .filter((item) => !Utils.canUseItem(item))
                    .sort((a, b) => a.name < b.name ? -1 : 1)
                : [];
    }

    #_buffs = null;
    get buffs() {
        return this.#_buffs ??=
            this.actor.items
                ? this.actor.items
                    .filter((item) => item.type === 'buff')
                    .sort((a, b) => a.name < b.name ? -1 : 1)
                : [];
    }

    constructor({ actor, token } = { actor: {}, token: {} }) {
        if (!canvas.tokens.controlled.length) {
            // covers the case for "always show my actor bar" when this is called without a selection
            this.#_fallbackActor = actor;
            this.#_fallbackToken = token;
        }
    }
}

class RollHandlerActorData extends ActionBuilderActorData {
    actionId = null;
    book = null;
    enable = null;
    item = null;
    rollType = null;
    subAction = null;

    constructor(action = {}) {
        const { actorId, book, enable, tokenId, actionId, rollType, subActionId } = action;
        const itemId = [ROLL_TYPE.buff, ROLL_TYPE.item].includes(rollType) ? actionId : '';

        const actor = Utils.getActor(actorId, tokenId);
        const token = Utils.getToken(tokenId);

        super({ actor, token });

        if (itemId) {
            this.item = Utils.getItem(actor, action.actionId);

            if (subActionId) {
                this.subAction = this.item.actions.find((a) => a.id === subActionId);
            }
        }

        this.actionId = actionId;
        this.book = book;
        this.enable = enable || false;
        this.rollType = rollType;
    }
}

/**
 *  see https://foundryvtt.wiki/en/development/api/settings for defaults
 */

const keys = {
    actionLayout: 'actionLayout',
    categorizeSkills: 'categorizeSkills',
    hideUntrainedSkills: 'hideUntrainedSkills',
    migrationVersion: 'migrationVersion',
    showModifiers: 'showModifiers',
    showPassiveFeatures: 'showPassiveFeatures',
    showPassiveInventory: 'showPassiveInventory',
    simplifySkillNames: 'simplifySkillNames',
    spellPreparation: 'spellPreparation',
};

function register(updateFunc) {
    const defaultSetting = {
        config: true,
        scope: 'client',
        onChange: (value) => {
            updateFunc(value);
        },
    };

    const settings = {
        [keys.actionLayout]: {
            choices: {
                'onlyItems': Utils.localize('settings.actionLayout.choices.onlyItems'),
                'onlyActions': Utils.localize('settings.actionLayout.choices.onlyActions'),
                'categorized': Utils.localize('settings.actionLayout.choices.categorized'),
            },
            default: 'categorized',
            type: String,
        },
        [keys.showModifiers]: {
            default: true,
            type: Boolean,
        },
        [keys.categorizeSkills]: {
            default: true,
            type: Boolean,
        },
        [keys.hideUntrainedSkills]: {
            default: false,
            type: Boolean,
        },
        [keys.showPassiveFeatures]: {
            default: false,
            type: Boolean,
        },
        [keys.showPassiveInventory]: {
            default: false,
            type: Boolean,
        },
        [keys.simplifySkillNames]: {
            default: true,
            type: Boolean,
        },
        [keys.spellPreparation]: {
            ...defaultSetting,
            choices: {
                'onlyRemaining': Utils.localize('settings.spellPreparation.choices.onlyRemaining'),
                'allPrepared': Utils.localize('settings.spellPreparation.choices.allPrepared'),
                'allSpells': Utils.localize('settings.spellPreparation.choices.allSpells'),
            },
            default: 'onlyRemaining',
            type: String,
        },
    };

    Object.keys(settings)
        .forEach((key) =>
            game.settings.register(MODULE.ID, key, {
                ...defaultSetting,
                name: Utils.localize(`settings.${key}.name`),
                hint: Utils.localize(`settings.${key}.hint`),
                ...settings[key],
            })
        );
}

class Settings {
    /**
     * User: determines how to layout sub-actions
     */
    static get actionLayout() {
        return Settings.#getSetting(keys.actionLayout);
    }

    static get categorizeSkills() {
        return Settings.#getSetting(keys.categorizeSkills);
    }

    static get hideUntrainedSkills() {
        return Settings.#getSetting(keys.hideUntrainedSkills);
    }

    static get migrationVersion() {
        return Settings.#getSetting(keys.migrationVersion);
    }

    static set migrationVersion(version) {
        Settings.#setSetting(keys.migrationVersion, version);
    }

    /**
     * @returns {boolean} Simplifies skill names to only the name in parenthesis
     */
    static get simplifySkillNames() {
        return Settings.#getSetting(keys.simplifySkillNames);
    }

    /**
     * @returns {boolean} Simplifies skill names to only the name in parenthesis
     */
    static set simplifySkillNames(value) {
        return Settings.#setSetting(keys.simplifySkillNames, value);
    }

    /**
     * @returns {boolean} Should show roll modifiers
     */
    static get showModifiers() {
        return Settings.#getSetting(keys.showModifiers);
    }

    static get showPassiveFeatures() {
        return Settings.#getSetting(keys.showPassiveFeatures);
    }

    static get showPassiveInventory() {
        return Settings.#getSetting(keys.showPassiveInventory);
    }

    static get spellPreparation() {
        return Settings.#getSetting(keys.spellPreparation);
    }

    static get pf1SkipActionDialogs() {
        return Settings.#getSetting('skipActionDialogs', 'pf1');
    }

    static get tahGrid() {
        return Settings.#getSetting('grid', 'token-action-hud-core');
    }

    static async toggleSkipDialog() {
        const current = Settings.pf1SkipActionDialogs;
        await Settings.#setSetting('skipActionDialogs', !current, 'pf1');
    }

    static async toggleTahGrid() {
        const current = Settings.tahGrid;
        await Settings.#setSetting('grid', !current, 'token-action-hud-core');
    }

    static async toggleUntrainedSkills() {
        const current = Settings.hideUntrainedSkills;
        await Settings.#setSetting(keys.hideUntrainedSkills, !current);
    }

    static #getSetting(key, moduleId = MODULE.ID) {
        return game.settings.get(moduleId, key);
    }

    static async #setSetting(key, value, moduleId = MODULE.ID) {
        await game.settings.set(moduleId, key, value);
    }
}

let HudBuilder = null;

Hooks.once('tokenActionHudCoreApiReady', async (coreModule) => {
    HudBuilder = class HudBuilder extends coreModule.api.ActionHandler {
        actorData = new ActionBuilderActorData();

        /**
         * Build System Actions
         * @override
         * @param {array} groupIds
         */
        async buildSystemActions(_groupIds) {
            const { actor, token } = this;
            this.actorData = new ActionBuilderActorData({ actor, token });

            if (!this.actorData.isValid) {
                return;
            }

            this.#_buildSkills();
            this.#_buildSaves();
            this.#_buildChecks();
            this.#_buildConditions();

            this.#_buildCombat();
            this.#_buildBuffs();
            this.#_buildInventory();
            this.#_buildSpells();
            this.#_buildFeatures();
            this.#_buildOtherItems();
            this.#_buildUtils();
        }

        /**
         * This override lets me call with a fully defined group without blowing up core logic
         *  @override */
        addActions(actions, subcateogry) {
            const { name, id } = subcateogry;
            super.addActions(actions, { name, id });
        }

        // could change this to directly take an info object instead if more than just "info1" is needed later
        #hasInfoChanged(sub1, sub2) {
            return sub1?.info1?.class !== sub2?.info1?.class
                || sub1?.info1?.title !== sub2?.info1?.title
                || sub1?.info1?.text !== sub2?.info1?.text;
        }

        // todo no category manager in v1.4 - quick patch for 1.4
        /**
         * This override lets me call with a fully defined parent group without blowing up core logic
         *  @override */
        addGroup(groupData, parentGroupData) {
            const { type, id } = parentGroupData;

            // todo
            const current = Object.values(game.tokenActionHud.actionHandler.groups).find((g) => g.id === groupData.id);
            const infoChanged = !!current && this.#hasInfoChanged(groupData, current);

            if (!infoChanged) {
                super.addGroup(groupData, { type, id });
            }
            else {
                current.info1 = groupData.info1;
                super.updateGroup(current, { type, id });
            }
        }

        #_buildChecks() {
            const saves = Object.keys(pf1.config.abilities);

            const actions = saves.map((key) => ({
                id: `ability-${key}`,
                info1: this.#modToInfo(this.actorData.actor.system.abilities[key].mod),
                encodedValue: this.#_encodeData(ROLL_TYPE.abilityCheck, key),
                name: pf1.config.abilities[key],
            }));
            this.addActions(actions, GROUP_MAP.checks.groups.checks);
        }

        #_buildSaves() {
            const saves = Object.keys(pf1.config.savingThrows);

            const actions = saves.map((key) => ({
                id: `save-${key}`,
                encodedValue: this.#_encodeData(ROLL_TYPE.save, key),
                info1: this.#modToInfo(this.actorData.actor.system.attributes.savingThrows[key].total),
                name: pf1.config.savingThrows[key],
            }));
            this.addActions(actions, GROUP_MAP.saves.groups.saves);
        }

        #_buildUtils() {
            const { groups } = GROUP_MAP.utility;

            const rest = {
                id: 'util-rest',
                name: Utils.localize('PF1.Rest'),
                encodedValue: this.#_encodeData(ROLL_TYPE.rest),
            };
            this.addActions([rest], groups.rest);

            const tokenActions = [];
            if (game.user.isGM) {
                const isHidden = this.actorData.tokens
                    .every((token) => token.document.hidden);
                tokenActions.push(isHidden ? {
                    id: 'util-makeVisible',
                    name: Utils.localize('categories.makeVisible'),
                    encodedValue: this.#_encodeData(ROLL_TYPE.makeVisible),
                } : {
                    id: 'util-makeInvisible',
                    name: Utils.localize('categories.makeInvisible'),
                    encodedValue: this.#_encodeData(ROLL_TYPE.makeInvisible),
                });
            }

            if (game.user.can('TOKEN_CONFIGURE')
                && this.actorData.tokens.every((token) => token.isOwner)
            ) {
                tokenActions.push({
                    id: 'util-openTokenConfig',
                    name: Utils.localize('actions.openTokenConfig'),
                    encodedValue: this.#_encodeData(ROLL_TYPE.openTokenConfig),
                });
            }            this.addActions(tokenActions, groups.token);

            const utilActions = [{
                id: 'util-toggleTahGrid',
                name: Utils.localize('actions.toggleTahGrid'),
                encodedValue: this.#_encodeData(ROLL_TYPE.toggleTahGrid),
                cssClass: Settings.tahGrid ? ' active' : '',
            }, {
                id: 'util-toggleSkip',
                name: Utils.localize(Settings.pf1SkipActionDialogs ? 'actions.toggleSkipEnabled' : 'actions.toggleSkipDisabled'),
                encodedValue: this.#_encodeData(ROLL_TYPE.toggleSkip),
                cssClass: Settings.pf1SkipActionDialogs ? ' active' : '',
            }, {
                id: 'util-openSettings',
                name: Utils.localize('actions.openSettings'),
                encodedValue: this.#_encodeData(ROLL_TYPE.openSettings),
            }];
            this.addActions(utilActions, groups.utility);
        }

        #_buildCombat() {
            const { groups } = GROUP_MAP.combat;

            let meleeMod, rangedMod;

            if (this.actorData.isSingle) {
                const { system } = this.actorData.actor;
                const attributes = system.attributes;
                const abilities = system.abilities;
                const sizeModifier = pf1.config.sizeMods[system.traits.size];
                const baseBonus = attributes.attack.shared + attributes.attack.general + sizeModifier;
                const meleeAbility = abilities[attributes.attack.meleeAbility]?.mod ?? 0;
                const rangedAbility = abilities[attributes.attack.rangedAbility]?.mod ?? 0;

                meleeMod = baseBonus + attributes.attack.melee + meleeAbility;
                rangedMod = baseBonus + attributes.attack.ranged + rangedAbility;
            }

            const basicActions = [{
                id: 'combat-showDefenses',
                name: Utils.localize('actions.displayDefenses'),
                encodedValue: this.#_encodeData(ROLL_TYPE.defenses),
            }, {
                id: 'combat-bab',
                encodedValue: this.#_encodeData(ROLL_TYPE.bab),
                info1: this.#modToInfo(this.actorData.actor.system.attributes.bab.total),
                name: Utils.localize('PF1.BABAbbr'),
            }, {
                id: 'combat-cmb',
                encodedValue: this.#_encodeData(ROLL_TYPE.cmb),
                info1: this.#modToInfo(this.actorData.actor.system.attributes.cmb.total),
                name: Utils.localize('PF1.CMBAbbr'),
            }, {
                id: 'combat-melee',
                encodedValue: this.#_encodeData(ROLL_TYPE.melee),
                info1: this.#modToInfo(meleeMod),
                name: Utils.localize('PF1.Melee'),
            }, {
                id: 'combat-ranged',
                encodedValue: this.#_encodeData(ROLL_TYPE.ranged),
                info1: this.#modToInfo(rangedMod),
                name: Utils.localize('PF1.Ranged'),
            }, {
                id: 'combat-initiative',
                name: Utils.localize('PF1.Initiative'),
                encodedValue: this.#_encodeData(ROLL_TYPE.initiative),
                cssClass: `${this.actorData.inCombat ? 'active' : ''} ${game.user.isGM ? '' : 'flat-disabled'}`,
                info1: this.actorData.combatant.initiative === null
                    ? this.#modToInfo(this.actorData.actor.system.attributes.init.total)
                    : { text: this.actorData.combatant.initiative },
            }];

            if (game.user.isGM) {
                const action = this.actorData.inCombat ? {
                    id: 'combat-removeFromCombat',
                    name: Utils.localize('COMBAT.CombatantRemove'),
                    encodedValue: this.#_encodeData(ROLL_TYPE.removeFromCombat),
                } : {
                    id: 'combat-addToCombat',
                    name: Utils.localize('COMBAT.CombatantCreate'),
                    encodedValue: this.#_encodeData(ROLL_TYPE.addToCombat),
                };
                basicActions.push(action);
            }

            if (this.actorData.isCurrentCombatant) {
                basicActions.push({
                    id: 'combat-endTurn',
                    name: Utils.localize('COMBAT.TurnEnd'),
                    encodedValue: this.#_encodeData(ROLL_TYPE.endTurn),
                });
            }

            this.addActions(basicActions, groups.base);

            if (this.actorData.isMulti) {
                return;
            }

            Object.entries(groups)
                .filter(([key, _]) => key !== 'base')
                .map(([_, g]) => g)
                .forEach((group) => this.#_buildFilteredItemActions(group, Settings.showPassiveInventory));
        }

        #_buildBuffs() {
            if (this.actorData.isMulti) {
                return;
            }

            const mapBuff = (buff) => ({
                cssClass: 'toggle' + (buff.isActive ? ' active' : ''),
                encodedValue: this.#_encodeData(ROLL_TYPE.buff, buff.id, { enable: !buff.isActive }),
                id: buff.id,
                img: buff.img,
                name: buff.name,
            });

            const addBuffs = (subType, group) => {
                const buffs = this.actorData.buffs
                    .filter((buff) => buff.subType === subType)
                    .map(mapBuff);
                this.addActions(buffs, group);
            };

            const { groups } = GROUP_MAP.buffs;

            addBuffs('item', groups.item);
            addBuffs('temp', groups.temporary);
            addBuffs('perm', groups.permanent);
            addBuffs('misc', groups.miscellaneous);

            const withActions = this.actorData.buffs
                .filter((buff) => buff.isActive && Utils.getItemActions(buff).length > 0);
            this.#_addItemActions(withActions, groups.actions, { actionLayout: 'onlyActions' });

            // leftovers that could be from other mods or from a change in pf1
            const otherBuffs = this.actorData.buffs
                .filter((item) => !['item', 'temp', 'perm', 'misc'].includes(item.subType))
                .map(mapBuff);
            this.addActions(otherBuffs, groups.other);
        }

        #_buildFeatures() {
            if (this.actorData.isMulti) {
                return;
            }

            Object.values(GROUP_MAP.features.groups)
                .forEach((group) => this.#_buildFilteredItemActions(group, Settings.showPassiveInventory));
        }

        #_buildOtherItems() {
            if (this.actorData.isMulti) {
                return;
            }

            this.#_buildFilteredItemActions(GROUP_MAP.other.groups.other, Settings.showPassiveFeatures);
        }

        #_buildInventory() {
            if (this.actorData.isMulti) {
                return;
            }

            Object.values(GROUP_MAP.inventory.groups)
                .forEach((group) => this.#_buildFilteredItemActions(group, Settings.showPassiveInventory));
        }

        #toSignedString = (mod) => !mod ? 'Â±0' : mod > 0 ? `+${mod}` : `${mod}`;
        #modToInfo = (mod) => Settings.showModifiers && this.actorData.isSingle ? { class: 'roll-modifier', text: this.#toSignedString(mod) } : undefined;

        #knowledgeSkillIds = ['kar', 'kdu', 'ken', 'kge', 'khi', 'klo', 'kna', 'kno', 'kpl', 'kre'];
        #_buildSkills() {
            const skillGroup = GROUP_MAP.skills.groups.skills;

            const actorSkills = this.actorData.isMulti
                ? pf1.config.skills
                : this.actorData.actor.system.skills;

            const excludedSkills = game.settings.get('pf1', 'allowBackgroundSkills')
                ? []
                : CONFIG.PF1.backgroundOnlySkills;

            const skillIds = Object.keys(actorSkills).filter((id) => !excludedSkills.includes(id));

            const getParentheticalName = (original) => /\(([^)]+)\)/g.exec(original)?.[1] || original;

            const nameFilter = (name) => Settings.simplifySkillNames
                ? getParentheticalName(name)
                : name;

            if (Settings.categorizeSkills) {
                const skills = skillIds
                    .filter((id) => this.actorData.isMulti || Utils.isEmptyObject(actorSkills[id].subSkills || {}))
                    .filter((id) => !this.#knowledgeSkillIds.includes(id))
                    .map((id) => ({ id, name: pf1.config.skills[id] || actorSkills[id].name }));
                const actions = skills
                    .filter(({ id }) => !Settings.hideUntrainedSkills || !actorSkills[id]?.rt || !!actorSkills[id].rank)
                    .map(({ id, name }) => ({
                        id: `skill_${id}`,
                        cssClass: this.actorData.isSingle && actorSkills[id].rt && !actorSkills[id].rank ? 'action-nulled-out' : '',
                        encodedValue: this.#_encodeData(ROLL_TYPE.skill, id),
                        info1: this.#modToInfo(actorSkills[id]?.mod),
                        name: nameFilter(name),
                    }));

                if (this.actorData.isSingle) {
                    const subSkillIds = Object.keys(actorSkills).filter((id) => !Utils.isEmptyObject(actorSkills[id].subSkills || {}));
                    subSkillIds.forEach((id) => {
                        const currentSubskills = actorSkills[id].subSkills;
                        const subskillActions = currentSubskills
                            ? Object.keys(currentSubskills)
                                .filter((sid) => !Settings.hideUntrainedSkills || !currentSubskills[sid].rt || !!currentSubskills[sid].rank)
                                .map((sid) => ({
                                    id: `categorized-${id}.subSkills.${sid}`,
                                    cssClass: currentSubskills[sid].rt && !currentSubskills[sid].rank ? 'action-nulled-out' : '',
                                    encodedValue: this.#_encodeData(ROLL_TYPE.skill, `${id}.subSkills.${sid}`),
                                    info1: this.#modToInfo(currentSubskills[sid].mod),
                                    name: nameFilter(currentSubskills[sid].name),
                                }))
                            : [];

                        if (subskillActions.length) {
                            const groupedActions =
                                !Settings.hideUntrainedSkills || !actorSkills[id].rt || !!actorSkills[id].rank
                                    ? [
                                        {
                                            id: `categorized-${id}`,
                                            cssClass: actorSkills[id].rt && !actorSkills[id].rank ? 'action-nulled-out' : '',
                                            encodedValue: this.#_encodeData(ROLL_TYPE.skill, id),
                                            info1: this.#modToInfo(actorSkills[id].mod),
                                            name: nameFilter(pf1.config.skills[id] || actorSkills[id].name),
                                        },
                                        ...subskillActions,
                                    ]
                                    : subskillActions;
                            const subSkillGroup = {
                                id: `${skillGroup.id}-${id}`,
                                name: groupedActions[0].name,
                                type: 'system-derived',
                            };
                            this.addGroup(subSkillGroup, skillGroup);
                            this.addActions(groupedActions, subSkillGroup);
                        }
                        else {
                            // if there are no subskills don't categorize it
                            // (e.g. if the actor doesn't have any specific "perform" skills, then just put the single generic "perform" skill alongside the rest of the non-categorized skills)
                            if (!Settings.hideUntrainedSkills || !actorSkills[id].rt || !!actorSkills[id].rank) {
                                actions.push({
                                    id,
                                    cssClass: actorSkills[id].rt && !actorSkills[id].rank ? 'action-nulled-out' : '',
                                    encodedValue: this.#_encodeData(ROLL_TYPE.skill, id),
                                    info1: this.#modToInfo(actorSkills[id].mod),
                                    name: nameFilter(pf1.config.skills[id] || actorSkills[id].name),
                                });
                            }
                        }
                    });
                }

                const knowledges = this.#knowledgeSkillIds
                    .filter((id) => !Settings.hideUntrainedSkills || !actorSkills[id].rt || !!actorSkills[id].rank)
                    .map((id) => ({
                        id: `categorized-${id}`,
                        cssClass: this.actorData.isSingle && actorSkills[id].rt && !actorSkills[id].rank ? 'action-nulled-out' : '',
                        encodedValue: this.#_encodeData(ROLL_TYPE.skill, id),
                        info1: this.#modToInfo(actorSkills[id]?.mod),
                        name: nameFilter(getParentheticalName(pf1.config.skills[id])),
                    }));
                const knowledgeGroupData = {
                    id: `${skillGroup.id}-knowledge`,
                    name: Utils.localize('token-action-hud-pf1.knowledge-skills'),
                    type: 'system-derived',
                };
                this.addGroup(knowledgeGroupData, skillGroup);
                this.addActions(knowledges, knowledgeGroupData);

                const sorted = [...actions].sort((a, b) => a.name < b.name ? -1 : 1);
                this.addActions(sorted, skillGroup);
            }
            else {
                const getSubskills = (key) => actorSkills[key].subSkills
                    ? Object.keys(actorSkills[key].subSkills).map((s) => ({
                        id: `${key}.subSkills.${s}`,
                        ...actorSkills[key].subSkills[s], // rank, name, rt
                    }))
                    : [];
                const skills = [
                    ...skillIds.map((id) => ({
                        id,
                        name: pf1.config.skills[id],
                        ...actorSkills[id], // rank, name (if it exists overwrite previous), rt
                    })),
                    ...skillIds.flatMap(getSubskills),
                ];
                const actions = skills
                    .filter(({ rank, rt }) => !Settings.hideUntrainedSkills || !rt || !!rank)
                    .map(({ id, name, rt }) => ({
                        id,
                        cssClass: this.actorData.isSingle && rt && !actorSkills[id]?.rank ? 'action-nulled-out' : '',
                        encodedValue: this.#_encodeData(ROLL_TYPE.skill, id),
                        info1: this.#modToInfo(actorSkills[id]?.mod),
                        name: nameFilter(name),
                    }));
                const sorted = [...actions].sort((a, b) => a.name < b.name ? -1 : 1);

                this.addActions(sorted, skillGroup);
            }

            // add skill utilities
            {
                const utils = [];
                const areHidden = Settings.hideUntrainedSkills;
                utils.push(areHidden ? {
                    id: 'util-makeVisible',
                    name: Utils.localize('actions.toggleUntrainedSkillsDisabled'),
                    encodedValue: this.#_encodeData(ROLL_TYPE.toggleUntrainedSkills),
                } : {
                    id: 'util-makeInvisible',
                    name: Utils.localize('actions.toggleUntrainedSkillsEnabled'),
                    encodedValue: this.#_encodeData(ROLL_TYPE.toggleUntrainedSkills),
                });

                this.addActions(utils, GROUP_MAP.skills.groups.utils);
            }
        }

        #_buildConditions() {
            const actions = pf1.registry.conditions.contents.map(({ id, name, texture }) => {
                const isEnabled = this.actorData.actors.every((actor) => actor.hasCondition(id));
                return {
                    cssClass: 'toggle' + (isEnabled ? ' active' : ''),
                    encodedValue: this.#_encodeData(ROLL_TYPE.condition, id, { enable: !isEnabled }),
                    id,
                    img: texture,
                    name,
                };
            });

            this.addActions(actions, GROUP_MAP.conditions.groups.conditions);
        }

        #_buildSpells() {
            if (this.actorData.isMulti) {
                return;
            }

            const spellGroup = GROUP_MAP.spells.groups.spells;
            const allSpells = this.actorData.items
                .filter((item) => item.type === 'spell');

            const spellbookKeys = Object.keys(this.actorData.actor.system.attributes.spells.spellbooks)
                .map((key) => ({ key, spellbook: this.actorData.actor.system.attributes.spells.spellbooks[key] }))
                .filter(({ _key, spellbook }) => spellbook.inUse)
                .map(({ key, _spellbook }) => key);

            const { spellbooks } = this.actorData.actor.system.attributes.spells;
            const levels = Array.from(Array(10).keys());

            spellbookKeys.forEach((key) => {
                const spellbook = spellbooks[key];
                let spellbookGroup = spellGroup;
                if (spellbookKeys.length > 1) {
                    spellbookGroup = {
                        id: `${spellGroup.id}-${key}`,
                        name: Utils.localize(spellbook.label) || spellbook.name,
                        type: 'system-derived',
                        settings: { style: 'tab' },
                    };
                    this.addGroup(spellbookGroup, spellGroup);
                }

                // todo add roll icons
                const basicActions = [
                    {
                        id: `casterLevel-${key}`,
                        name: Utils.localize('PF1.CasterLevelCheck'),
                        encodedValue: this.#_encodeData(ROLL_TYPE.casterLevel, 'casterLevel', { book: key }),
                    },
                    {
                        id: `concentration-${key}`,
                        name: Utils.localize('PF1.ConcentrationCheck'),
                        encodedValue: this.#_encodeData(ROLL_TYPE.concentration, 'concentration', { book: key }),
                    },
                ];
                this.addActions(basicActions, spellbookGroup);

                let prepFilter;
                switch (Settings.spellPreparation) {
                    case 'allSpells':
                        prepFilter = (_spell) => true;
                        break;
                    case 'allPrepared':
                        prepFilter = (spell) => !!spell.maxCharges;
                        break;
                    case 'onlyRemaining':
                    default:
                        prepFilter = (spell) => (spell.charges || 0) - (spell.slotCost || 0) >= 0;
                        // todo v10
                        //prepFilter = (spell) => !!spell.canUse;
                        break;
                }

                const bookSpells = allSpells.filter((spell) => spell.system.spellbook === key && prepFilter(spell));

                levels.forEach((level) => {
                    const levelGroup = {
                        id: `${spellbookGroup.id}-${level}`,
                        name: Utils.localize(`PF1.SpellLevels.${level}`),
                        type: 'system-derived',
                    };

                    const spellLevel = spellbook.spells[`spell${level}`];
                    if (level && spellbook.spontaneous && spellLevel.max) {
                        levelGroup.info1 = { text: `${spellLevel.value || 0}/${spellLevel.max}` };
                    }

                    this.addGroup(levelGroup, spellbookGroup);

                    const itemChargeInfo = (spell) => spellbook.spontaneous
                        ? {}
                        : { text: spell.maxCharges === Number.POSITIVE_INFINITY ? '' : `${spell.charges}/${spell.maxCharges}` };

                    const levelSpells = bookSpells.filter((item) => item.system.level === level);
                    this.#_addItemActions(levelSpells, levelGroup, { itemChargeInfo, actionChargeInfo: () => ({}) });
                });
            });
        }

        /**
         * @param {{id: string, name: string, filter: (ItemPF): booelean}} parentGroup
         * @param {boolean} includeUnusable
         */
        #_buildFilteredItemActions(parentGroup, includeUnusable = false) {
            if (this.actorData.isMulti) {
                return;
            }

            const { filter } = parentGroup;

            const filtered = this.actorData.items.filter(filter);
            this.#_addItemActions(filtered, parentGroup);

            if (includeUnusable) {
                const unusable = this.actorData.unusableItems.filter(filter);
                const itemGroup = {
                    id: `${parentGroup.id}-unusable`,
                    name: Utils.localize('PF1.ActivationTypePassive'),
                    type: 'system-derived',
                };
                this.addGroup(itemGroup, parentGroup);
                this.#_addItemActions(unusable, itemGroup);
            }
        }

        #_encodeData = (
            rollType,
            actionId,
            extraData = {},
        ) => JSON.stringify({
            rollType,
            actionId,
            actorId: this.actorData.isMulti ? '' : this.actorData.actorId,
            tokenId: this.actorData.isMulti ? '' : this.actorData.tokenId,
            isMulti: this.actorData.isMulti,
            ...extraData,
        });

        #_addItemActions(
            items,
            parentGroupData, {
                itemChargeInfo = null,
                actionChargeInfo = null,
                actionLayout = Settings.actionLayout,
            } = {}) {
            if (this.actorData.isMulti) {
                return;
            }

            const info1 = (_item) => ({});
            const info2 = (_item) => ({});

            itemChargeInfo ??= (item) => item.maxCharges && item.maxCharges !== Number.POSITIVE_INFINITY
                ? { text: `${item.charges}/${item.maxCharges}`, class: 'charged' }
                : {};
            actionChargeInfo ??= (action) => {
                const { self } = action.data.uses;
                const cost = action.getChargeCost();
                const values = [];
                if (cost) {
                    values.push(cost);
                }
                if (action.isSelfCharged && self.max) {
                    values.push(`${self.value}/${self.max}`);
                }
                return { text: values.join(', '), class: 'charged' };
            };

            const mapItemToAction = (item, idType) => ({
                id: `${item.id}-${idType}-${item.id}`,
                img: item.img,
                name: item.name,
                encodedValue: this.#_encodeData(ROLL_TYPE.item, item.id),
                info1: info1(),
                info2: info2(),
                info3: itemChargeInfo(item),
            });
            const mapSubActionToAction = (item, action, idType, { name } = { name: action.name }) => ({
                id: `${idType}-${item.id}-${action.id}`,
                img: action.img || item.img,
                name: name,
                encodedValue: this.#_encodeData(ROLL_TYPE.item, item.id, { subActionId: action.id }),
                info1: info1(),
                info2: info2(),
                info3: actionChargeInfo(action),
            });

            switch (actionLayout) {
                case 'onlyItems': {
                    const actions = items.map((item) => mapItemToAction(item, 'onlyItems'));
                    this.addActions(actions, parentGroupData);
                } break;
                case 'onlyActions': {
                    const actions = (items.flatMap((item) => Utils.getItemActions(item).length > 1
                        ? Utils.getItemActions(item).map((action) => mapSubActionToAction(item, action, 'onlyActions', { name: `${item.name} - ${action.name}` }))
                        : mapItemToAction(item, 'onlyActions')));
                    this.addActions(actions, parentGroupData);
                } break;
                case 'categorized':
                default: {
                    items.forEach((item) => {
                        if (Utils.getItemActions(item).length > 1) {
                            const subActions = item.actions.map((action) => mapSubActionToAction(item, action, 'categorized'));

                            const groupData = {
                                id: `${parentGroupData.id}-${item.id}`,
                                info1: itemChargeInfo(item),
                                name: item.name,
                                type: 'system-derived',
                            };
                            this.addGroup(groupData, parentGroupData);
                            this.addActions(subActions, groupData);
                        }
                        else {
                            // has a use script call or a single action
                            const action = mapItemToAction(item, 'categorized');
                            this.addActions([action], parentGroupData);
                        }
                    });
                } break;
            }
        }
    };
});

let RollHandler = null;

Hooks.once('tokenActionHudCoreApiReady', async (coreModule) => {
    RollHandler = class RollHandler extends coreModule.api.RollHandler {

        actorData = new RollHandlerActorData();

        get skipActionDialog() {
            const skip = Settings.pf1SkipActionDialogs;
            return skip !== this.shift;
        }

        #logInvalidMulti = () => {
            console.error(`TAH - this shouldn't happen`, action);
            ui.notifications.warn(`TAH tried to perform an action that wasn't intended for multiple tokens`);
        };

        #logInvalidAction = () => {
            console.error(`TAH - this shouldn't happen`, action);
            ui.notifications.warn(`TAH tried to perform an action that doesn't exist`);
        }

        /**
         * Handle Action Event
         * @override
         * @param {object} event
         * @param {string} encodedValue
         */
        async handleActionClick(event, encodedValue) {
            const action = JSON.parse(encodedValue);
            this.actorData = new RollHandlerActorData(action);

            const { actionId, actor, actors, book, enable, rollType, tokens } = this.actorData;

            switch (rollType) {
                case ROLL_TYPE.abilityCheck: await Promise.all(actors.map((actor) => actor.rollAbilityTest(actionId, { skipDialog: this.skipActionDialog }))); break;
                case ROLL_TYPE.addToCombat: await this.#_addToCombat(); break;
                case ROLL_TYPE.bab: await Promise.all(actors.map((actor) => actor.rollBAB({ skipDialog: this.skipActionDialog }))); break;
                case ROLL_TYPE.buff: await this.#_rollBuff(); break;
                case ROLL_TYPE.casterLevel: this.actorData.isMulti ? this.#logInvalidMulti() : await actor.rollCL(book, { skipDialog: this.skipActionDialog }); break;
                case ROLL_TYPE.cmb: await Promise.all(actors.map((actor) => actor.rollCMB({ skipDialog: this.skipActionDialog }))); break;
                case ROLL_TYPE.concentration: this.actorData.isMulti ? this.#logInvalidMulti() : await actor.rollConcentration(book, { skipDialog: this.skipActionDialog }); break;
                case ROLL_TYPE.condition: await Promise.all(actors.map((actor) => actor.setCondition(actionId, enable))); break;
                case ROLL_TYPE.defenses: await Promise.all(tokens.map((token) => token.actor.displayDefenseCard({ token }))); break;
                case ROLL_TYPE.endTurn: this.#_endTurn(); break;
                case ROLL_TYPE.initiative: await Promise.all(actors.map((actor) => actor.rollInitiative({ createCombatants: true, skipDialog: this.skipActionDialog, rerollInitiative: game.user.isGM }))); break;
                case ROLL_TYPE.item: await this.#_rollItem(); break;
                case ROLL_TYPE.makeInvisible: await this.#_makeInvisible(); break;
                case ROLL_TYPE.makeVisible: await this.#_makeVisible(); break;
                case ROLL_TYPE.melee: await Promise.all(actors.map((actor) => actor.rollAttack({ skipDialog: this.skipActionDialog, melee: true }))); break;
                case ROLL_TYPE.openSettings: await this.#_openSettings(); break;
                case ROLL_TYPE.openTokenConfig: tokens.map((token) => new TokenConfig(token.document).render(true)); break;
                case ROLL_TYPE.ranged: await Promise.all(actors.map((actor) => actor.rollAttack({ skipDialog: this.skipActionDialog, melee: false }))); break;
                case ROLL_TYPE.removeFromCombat: await this.#_removeFromCombat(); break;
                case ROLL_TYPE.rest: await this.#_rest(); break;
                case ROLL_TYPE.save: await Promise.all(actors.map((actor) => actor.rollSavingThrow(actionId, { skipDialog: this.skipActionDialog }))); break;
                case ROLL_TYPE.skill: await Promise.all(actors.map((actor) => actor.rollSkill(actionId, { skipDialog: this.skipActionDialog }))); break;
                case ROLL_TYPE.toggleSkip: await this.#_toggleSkipDialog(); break;
                case ROLL_TYPE.toggleTahGrid: await this.#_toggleTahGrid(); break;
                case ROLL_TYPE.toggleUntrainedSkills: await this.#_toggleUntrainedSkills(); break;
                default: this.#logInvalidAction(); break;
            }
        }

        async #_addToCombat() {
            if (canvas.tokens.controlled.length) {
                await canvas.tokens.toggleCombat(true, game.combat);
            }
            else {
                const { actorId, tokenId } = this.actorData;
                if (!(game.combat?.combatants || []).find((combatant) => combatant.actorId === actorId)) {
                    await Combatant.create({ actorId, tokenId }, { parent: game.combat });
                }
            }
            Hooks.callAll('forceUpdateTokenActionHud');
        }

        async #_endTurn() {
            if (this.actorData.isMulti) {
                this.#logInvalidMulti();
                return;
            }

            const combat = game.combat;
            if (combat && this.actorData.isCurrentCombatant) {
                await combat.nextTurn();
            }
        }

        async #_makeVisible() {
            await Promise.all(this.actorData.tokens
                .filter((token) => token.document.hidden)
                .map((token) => token.toggleVisibility())
            );
        }

        async #_makeInvisible() {
            await Promise.all(this.actorData.tokens
                .filter((token) => !token.document.hidden)
                .map((token) => token.toggleVisibility())
            );
        }

        async #_openSettings() {
            new SettingsConfig().render(true);
            await new Promise(r => setTimeout(r, 100)).then(() => ui.activeWindow.activateTab(MODULE.ID));
        }

        async #_removeFromCombat() {
            const combat = game.combat;
            if (!combat) {
                return;
            }

            if (canvas.tokens.controlled.length) {
                await canvas.tokens.toggleCombat(false, combat);
            }
            else {
                const { actorId, tokenId } = this.actorData;
                const combatant = combat.combatants.find((combatant) => combatant.actorId === actorId && combatant.tokenId === tokenId);
                if (combatant) {
                    await combat.deleteEmbeddedDocuments('Combatant', [combatant.id]);
                }
            }

            Hooks.callAll('forceUpdateTokenActionHud');
        }

        async #_rest() {
            this.actorData.actors.forEach((actor) => new pf1.applications.actor.ActorRestDialog(actor).render(true));
        }

        async #_rollBuff() {
            const { enable, isMulti, item: buff } = this.actorData;
            if (isMulti) {
                this.#logInvalidMulti();
                return;
            }

            await buff.setActive(enable);
        }

        async #_rollItem() {
            if (this.actorData.isMulti) {
                this.#logInvalidMulti();
                return;
            }

            const { item, subAction } = this.actorData;

            if (this.rightClick) {
                if (subAction) {
                    const app = new pf1.applications.component.ItemActionSheet(subAction);
                    app.render(true);
                    return;
                }
                item.sheet.render(true, { focus: true });
                return;
            }

            if (subAction) {
                item.use({ actionID: subAction.id, skipDialog: this.skipActionDialog });
            }
            else if (Utils.getItemActions(item).size === 1) {
                const actionId = Utils.getItemActions(item)[0].id;
                item.use({ actionID: actionId, skipDialog: this.skipActionDialog });
            }
            else {
                if (item.hasAction || item.getScriptCalls("use").length) {
                    item.use({ skipDialog: this.skipActionDialog });
                }
                else {
                    item.displayCard();
                }
            }
        }

        async #_toggleSkipDialog() {
            await Settings.toggleSkipDialog();
            Hooks.callAll('forceUpdateTokenActionHud');
        }

        async #_toggleTahGrid() {
            await Settings.toggleTahGrid();
            Hooks.callAll('forceUpdateTokenActionHud');
        }

        async #_toggleUntrainedSkills() {
            await Settings.toggleUntrainedSkills();
            Hooks.callAll('forceUpdateTokenActionHud');
        }
    };
});

// System Module Imports

let SystemManager = null;

Hooks.once('tokenActionHudCoreApiReady', async (coreModule) => {
    SystemManager = class SystemManager extends coreModule.api.SystemManager {
        // todo - what is this doing?
        /** @override */
        doGetCategoryManager(_user) {
            return new coreModule.api.CategoryManager();
        }

        /** @override */
        getActionHandler(categoryManager) {
            const actionHandler = new HudBuilder(categoryManager);
            return actionHandler;
        }

        /** @override */
        getAvailableRollHandlers() {
            const coreTitle = Utils.localize('PF1.Default');

            const choices = { core: coreTitle };

            return choices;
        }

        /** @override */
        getRollHandler(handlerId) {
            switch (handlerId) {
                case 'core':
                default:
                    return new RollHandler();
            }
        }

        /** @override */
        registerSettings(updateFunc) {
            register(updateFunc);
        }

        /** @override */
        async registerDefaults() {
            return GROUPS;
        }
    };
});

const migrate = async () => {
    game.settings.register(MODULE.ID, 'migrationVersion', {
        config: false,
        scope: 'client',
        default: '',
        type: String,
    });

    const lastMigrated = Settings.migrationVersion || 1;

    if (foundry.utils.isNewerVersion('1.2.0', lastMigrated)) {
        await game.user.unsetFlag(CORE_MODULE.ID, 'categories');
        await game.user.unsetFlag(CORE_MODULE.ID, 'default.categories');
    }

    const current = game.modules.get(MODULE.ID).version;
    Settings.migrationVersion = current;
};

Hooks.once('ready', async () => {
    const module = game.modules.get(MODULE.ID);
    module.api = {
        requiredCoreModuleVersion: REQUIRED_CORE_MODULE_VERSION,
        SystemManager
    };
    Hooks.call('tokenActionHudSystemReady', module);
});

Hooks.once('tokenActionHudCoreApiReady', async () => {
    await migrate();
});

export { ActionBuilderActorData, CORE_MODULE, GROUPS, GROUP_MAP, HudBuilder, MODULE, REQUIRED_CORE_MODULE_VERSION, ROLL_TYPE, RollHandler, RollHandlerActorData, Settings, SystemManager, Utils, migrate, register };
//# sourceMappingURL=token-action-hud-pf1.min.js.map
